#!/usr/bin/php
<?php

// parse the cli arguments out into "arguments" and "options" and return them as a keyed array
function parseParams($arguments = array(), $options = array()) {
    $params = $GLOBALS['argv'];
    $result = array();
    reset($params); // first param can be ignored
    // loop over all arguments
    while (($currentParam = next($params)) !== false) {
        // if the parameter starts with a `-` then it's an "option"
        if ($currentParam[0] === '-') {
            // trim off the starting `-` (we could have 1 or 2 due to legacy support)
            $param = ltrim($currentParam, '-');
            $value = true; // default value
            // a param could be `--` and that should be ignored
            if ($param) {
                // if the param has a `=` then we assume it's param=value
                if (strpos($param, '=') !== false) {
                    list($param, $value) = explode('=', $param, 2);
                } elseif (($nextParam = next($params)) !== false) {// check the next param to see if it's a value or not
                    // not a value, so move the array pointer back
                    if ($nextParam[0] === '-') {
                        prev($params);
                    } else {
                        // it's a valid value
                        $value = $nextParam;
                    }
                }
                // if the param is unknown then throw an error
                if (!in_array($param, $options)) {
                    echo "Unknown argument: $param" . PHP_EOL;
                    exit(1);
                }
                $result[$param] = $value;
            }
        } else {
            // no leading `-` so it's an "argument"
            if (!empty($arguments)) {
                // record the named arguments in the order they appear
                $result[array_shift($arguments)] = $currentParam;
            } else {
                // no arguments left so we've been supplied too many
                echo "Too many arguments supplied" . PHP_EOL;
                exit(1);
            }
        }
    }
    return $result;
}

function switch_to_project_root() {
    while (dirname(getcwd()) != "/") {
        foreach (scandir(".") as $file) {
            if ($file == ".." || $file == ".")
                continue;
            if (is_dir($file)) {
                if (file_exists($file . "/cli-script.php")) {
                    return $file;
                }
            }
        }
        chdir(dirname(getcwd()));
    }
    return false;
}



function run_process($cmd)
{
   $descriptorspec = array(
       0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
       1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
       2 => array("pipe", "w") // stderr is a file to write to
   );

   $pipes= array();
   $process = proc_open($cmd, $descriptorspec, $pipes);

   $output= "";

   if (!is_resource($process)) return false;

   #close child's input immediately
   fclose($pipes[0]);

   stream_set_blocking($pipes[1],false);
   stream_set_blocking($pipes[2],false);

   $todo= array($pipes[1],$pipes[2]);

   while( true ) {
       $read= array();
       if( !feof($pipes[1]) ) $read[]= $pipes[1];
       if( !feof($pipes[2]) ) $read[]= $pipes[2];

       if (!$read) break;
       $write = array();
       $ex = array();

       $ready= stream_select($read, $write, $ex, 2);

       if ($ready === false) {
           break; #should never happen - something died
       }

       foreach ($read as $r) {
           $s= fread($r,1024);
           echo $s;
           $output.= $s;
       }
   }

   fclose($pipes[1]);
   fclose($pipes[2]);

   return $output;

}

$help = "
	Usage: mockdata <generate|populate|cleanup>
	Options:
	\t--count\t\t\t\tThe number of records to create
	\t--relation-limit\t\t\tThe number of related records to create when relations are enabled
	\t--parent\t\t\t\tAn identifying ID, URLSegment of the parent object
	\t--parent-field\t\t\tThe parent field for the object being created. Defaults to ParentID. Only used when -parent is specified.
	\t
	\t--no-relations\t\t\tSuppress creation of related has_many/many_many records
	\t--no-downloads\t\t\tSuppress downloading of images. Use local stock images instead.
	\t--overwrite\t\t\tOverwrite fields that already have value.
";

if(!$framework_dir = switch_to_project_root()) {
	echo "Could not find the root of a SilverStripe project in this directory!";
	die();
}

$parsedParams = parseParams(
    array(
        'command',
        'class',
    ),
    array(
        'count',
        'relation-limit',
        'parent',
        'parent-field',
        'no-relations',
        'no-downloads',
    )
);

$operation = !empty($parsedParams['command']) ? $parsedParams['command'] : '';
$className = !empty($parsedParams['class']) ? $parsedParams['class'] : '';


if (empty($operation) || !in_array($operation, array('generate','populate','cleanup','help'))) {
	echo $help;
	exit(1);
}

if($operation == "help") {
    echo $help;
    exit (0);
}

if(!$className) {
  if($operation == "cleanup") {
    $className = "__all__";
  } else {
    echo $help;
    exit(1);
  }
}

$args = array();
$args[] = isset($parsedParams['parent']) ? "parent=".$parsedParams['parent'] : "";
$args[] = isset($parsedParams['parent-field']) ? "parentField=".$parsedParams['parent-field'] : "";
$args[] = isset($parsedParams['count']) ? "count=" . $parsedParams['count'] : "";
$args[] = isset($parsedParams['no-relations']) ? "includeRelations=false" : "";
$args[] = isset($parsedParams['no-downloads']) ? "downloadImages=false" : "";
$args[] = isset($parsedParams['relation-limit']) ? "relationCreateLimit=".$parsedParams['relation-limit'] : "";
$args[] = isset($parsedParams['overwrite']) ? "onlyEmpty=false" : "";

$arguments = implode(" ", $args);
$cmd = $framework_dir . "/sake dev/tasks/MockDataTask $operation $className $arguments flush=all";
run_process($cmd);
echo "\n\n";